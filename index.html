<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Memorama AR - Final Fix</title>
    <style>
        /* --- ESTILOS GENERALES --- */
        * { box-sizing: border-box; margin: 0; padding: 0; -webkit-tap-highlight-color: transparent; }
        body {
            background: #111; color: white; font-family: 'Segoe UI', sans-serif;
            overflow: hidden; position: fixed; width: 100%; height: 100%;
        }
        .container { position: relative; width: 100vw; height: 100vh; }
        
        #input_video { display: none; }
        #output_canvas {
            position: absolute; left: 0; top: 0; width: 100%; height: 100%;
            object-fit: cover; transform: scaleX(-1); /* EL CSS HACE EL EFECTO ESPEJO */
        }
        
        /* UI */
        .menu, .victory, .loading {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 30; background: rgba(0, 0, 0, 0.75); backdrop-filter: blur(8px);
            text-align: center; padding: 20px; transition: opacity 0.5s;
        }
        .hidden { display: none !important; opacity: 0; pointer-events: none; }
        
        h1 { font-size: 2.5rem; margin-bottom: 1rem; color: #FFD700; text-shadow: 0 0 20px rgba(255, 215, 0, 0.5); }
        
        .login-container {
            background: rgba(255, 255, 255, 0.1); padding: 20px; border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2); width: 100%; max-width: 400px; margin-bottom: 20px;
        }
        .input-group { margin-bottom: 15px; text-align: left; }
        .input-group label { display: block; margin-bottom: 5px; font-weight: bold; font-size: 0.9rem; color: #aaa; }
        .login-input {
            width: 100%; padding: 12px; border-radius: 10px; border: 2px solid rgba(255, 255, 255, 0.2);
            background: rgba(0, 0, 0, 0.4); color: white; font-size: 1.1rem; outline: none; text-align: center;
        }
        .login-input:focus { border-color: #00e5ff; background: rgba(0, 0, 0, 0.6); }

        .grid-btn {
            background: linear-gradient(135deg, #00c6ff, #0072ff); color: white; border: none;
            padding: 15px 30px; margin: 10px; border-radius: 50px; font-size: 1.1rem; font-weight: bold;
            cursor: pointer; transition: transform 0.2s, box-shadow 0.2s; box-shadow: 0 4px 15px rgba(0,114,255,0.4);
            min-width: 140px; text-transform: uppercase; letter-spacing: 1px;
        }
        .grid-btn:hover { transform: translateY(-3px); box-shadow: 0 8px 25px rgba(0,114,255,0.6); }
        .grid-btn:active { transform: scale(0.95); }

        /* HUD */
        .hud {
            position: absolute; top: 0; left: 0; width: 100%; padding: 10px;
            display: flex; justify-content: space-between; align-items: flex-start;
            z-index: 20; pointer-events: none;
        }
        .player-card {
            background: rgba(20, 20, 20, 0.8); padding: 8px 15px; border-radius: 15px;
            border: 2px solid rgba(255,255,255,0.1); transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            min-width: 100px;
        }
        .player-card.active {
            border-color: #00FF00; background: rgba(0, 50, 0, 0.8);
            transform: scale(1.1); box-shadow: 0 0 15px rgba(0, 255, 0, 0.4);
        }
        .timer-box {
            position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.7); padding: 5px 15px; border-radius: 20px;
            font-size: 1.2rem; font-weight: bold; font-family: monospace; border: 1px solid #555;
        }

        /* TABLA */
        .summary-table {
            width: 100%; max-width: 500px; border-collapse: collapse; margin: 20px 0;
            background: rgba(255, 255, 255, 0.05); border-radius: 10px; overflow: hidden;
        }
        .summary-table th, .summary-table td { padding: 15px; border-bottom: 1px solid rgba(255, 255, 255, 0.1); }
        .summary-table th { background: rgba(0, 114, 255, 0.3); color: white; }
        
        .back-btn {
            position: absolute; bottom: 20px; right: 20px; z-index: 25;
            background: rgba(255, 50, 50, 0.9); color: white; padding: 12px 25px; border-radius: 30px;
            border: none; font-weight: bold; cursor: pointer; display: none; pointer-events: auto;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }
        .back-btn.show { display: block; }
    </style>
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div class="container">
        <div id="menuScreen" class="menu">
            <h1>üë• Memorama Pro</h1>
            <div class="login-container">
                <div class="input-group">
                    <label>Jugador 1</label>
                    <input type="text" id="p1Input" class="login-input" placeholder="Nombre" value="Jugador 1">
                </div>
                <div class="input-group">
                    <label>Jugador 2</label>
                    <input type="text" id="p2Input" class="login-input" placeholder="Nombre" value="Jugador 2">
                </div>
            </div>
            <p style="margin-bottom:15px; color:#ccc;">Selecciona Categor√≠a:</p>
            <div>
                <button class="grid-btn" onclick="startGame('animals')">üê∂ Animales</button>
                <button class="grid-btn" onclick="startGame('fruits')">üçé Frutas</button>
                <button class="grid-btn" onclick="startGame('vehicles')">üöó Veh√≠culos</button>
            </div>
        </div>

        <div id="gameHUD" class="hud hidden">
            <div id="p1Card" class="player-card active">
                <div id="p1NameDisplay" style="font-weight:bold; font-size:1rem; margin-bottom:5px;">J1</div>
                <div style="color:#00e5ff;">‚≠ê <span id="p1Score">0</span></div>
                <div style="font-size:0.8rem; color:#ff6666;">‚ùå <span id="p1Errors">0</span></div>
            </div>
            <div class="timer-box" id="timerDisplay">00:00</div>
            <div id="p2Card" class="player-card">
                <div id="p2NameDisplay" style="font-weight:bold; font-size:1rem; margin-bottom:5px;">J2</div>
                <div style="color:#00e5ff;">‚≠ê <span id="p2Score">0</span></div>
                <div style="font-size:0.8rem; color:#ff6666;">‚ùå <span id="p2Errors">0</span></div>
            </div>
        </div>

        <div id="loadingMsg" class="loading hidden">
            <h2>üì∑ Iniciando c√°mara...</h2>
        </div>

        <div id="victoryScreen" class="victory hidden">
            <h1 style="margin-bottom:0;">¬°Juego Terminado!</h1>
            <p id="winnerText" style="font-size:1.5rem; color:#00FF00; margin-bottom:20px;">Ganador</p>
            
            <table class="summary-table">
                <thead><tr><th>Jugador</th><th>Pares</th><th>Errores</th></tr></thead>
                <tbody>
                    <tr><td id="sumP1Name">J1</td><td id="sumP1Score">0</td><td id="sumP1Errors">0</td></tr>
                    <tr><td id="sumP2Name">J2</td><td id="sumP2Score">0</td><td id="sumP2Errors">0</td></tr>
                </tbody>
            </table>
            <p>Tiempo: <span id="sumTime" style="font-weight:bold;">00:00</span></p>
            <div style="margin-top:20px;">
                <button class="grid-btn" onclick="resetGame()">üîÑ Reintentar</button>
                <button class="grid-btn" onclick="backToMenu()">üè† Men√∫</button>
            </div>
        </div>

        <button id="backBtn" class="back-btn" onclick="backToMenu()">‚ùå Salir</button>
        <video id="input_video" playsinline></video>
        <canvas id="output_canvas"></canvas>
    </div>

    <script>
        const videoElement = document.getElementById('input_video');
        const canvasElement = document.getElementById('output_canvas');
        const ctx = canvasElement.getContext('2d');
        
        // --- DATA ---
        const categories = {
            animals: [
                { emoji: 'üê∂', name: 'Perro' }, { emoji: 'üê±', name: 'Gato' },
                { emoji: 'üê≠', name: 'Rat√≥n' }, { emoji: 'üê∞', name: 'Conejo' },
                { emoji: 'ü¶ä', name: 'Zorro' }, { emoji: 'üêª', name: 'Oso' }
            ],
            fruits: [
                { emoji: 'üçé', name: 'Manzana' }, { emoji: 'üçå', name: 'Pl√°tano' },
                { emoji: 'üçá', name: 'Uvas' }, { emoji: 'üçâ', name: 'Sand√≠a' },
                { emoji: 'üçì', name: 'Fresa' }, { emoji: 'üçí', name: 'Cereza' }
            ],
            vehicles: [
                { emoji: 'üöó', name: 'Coche' }, { emoji: 'üöì', name: 'Polic√≠a' },
                { emoji: 'üöÄ', name: 'Cohete' }, { emoji: 'üöÅ', name: 'Helic√≥ptero' },
                { emoji: 'üöÇ', name: 'Tren' }, { emoji: 'üö≤', name: 'Bicicleta' }
            ]
        };

        let cards = [];
        let flippedCards = [];
        let lockBoard = false;
        let matchesFound = 0;
        let totalPairs = 0;
        let particles = [];
        let gameActive = false;
        let players = [{ name: "J1", score: 0, errors: 0 }, { name: "J2", score: 0, errors: 0 }];
        let currentPlayerIndex = 0;
        let startTime = 0;
        let timerInterval = null;
        let wasPinching = false; 
        let pinchCooldown = 0;   

        // --- SISTEMA DE SONIDO ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        function playSound(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            osc.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            const now = audioCtx.currentTime;

            if (type === 'flip') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(400, now);
                osc.frequency.exponentialRampToValueAtTime(800, now + 0.1);
                gainNode.gain.setValueAtTime(0.3, now);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
            } else if (type === 'match') {
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(600, now);
                osc.frequency.setValueAtTime(1200, now + 0.1);
                gainNode.gain.setValueAtTime(0.3, now);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
                osc.start(now);
                osc.stop(now + 0.5);
            } else if (type === 'error') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(150, now);
                osc.frequency.linearRampToValueAtTime(100, now + 0.3);
                gainNode.gain.setValueAtTime(0.2, now);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                osc.start(now);
                osc.stop(now + 0.3);
            }
        }

        function speak(text) {
            if ('speechSynthesis' in window) {
                window.speechSynthesis.cancel();
                const u = new SpeechSynthesisUtterance(text);
                u.lang = 'es-ES';
                u.rate = 1.1; 
                window.speechSynthesis.speak(u);
            }
        }

        function resizeCanvas() {
            canvasElement.width = window.innerWidth;
            canvasElement.height = window.innerHeight;
            if(gameActive) createGrid(); 
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        function startGame(category) {
            const name1 = document.getElementById('p1Input').value.trim() || "Jugador 1";
            const name2 = document.getElementById('p2Input').value.trim() || "Jugador 2";
            players = [{ name: name1, score: 0, errors: 0 }, { name: name2, score: 0, errors: 0 }];
            currentPlayerIndex = 0;

            document.getElementById('menuScreen').classList.add('hidden');
            document.getElementById('victoryScreen').classList.add('hidden');
            document.getElementById('loadingMsg').classList.remove('hidden');
            document.getElementById('gameHUD').classList.remove('hidden');
            document.getElementById('backBtn').classList.add('show');
            updateHUD();

            if (!videoElement.srcObject) startCamera();
            else document.getElementById('loadingMsg').classList.add('hidden');

            const items = categories[category];
            let deck = [...items, ...items]; 
            deck.sort(() => Math.random() - 0.5);

            totalPairs = items.length;
            matchesFound = 0;
            flippedCards = [];
            lockBoard = false;
            particles = [];

            cards = deck.map((item, index) => ({
                id: index,
                emoji: item.emoji,
                name: item.name,
                isFlipped: false,
                isMatched: false,
                x: 0, y: 0, w: 0, h: 0,
                scale: 1,
                floatOffset: Math.random() * Math.PI * 2
            }));

            gameActive = true;
            createGrid();
            
            startTime = Date.now();
            if(timerInterval) clearInterval(timerInterval);
            timerInterval = setInterval(updateTimerDisplay, 1000);

            speak("Turno de " + players[currentPlayerIndex].name);
        }

        function updateHUD() {
            document.getElementById('p1NameDisplay').innerText = players[0].name;
            document.getElementById('p1Score').innerText = players[0].score;
            document.getElementById('p1Errors').innerText = players[0].errors;
            document.getElementById('p2NameDisplay').innerText = players[1].name;
            document.getElementById('p2Score').innerText = players[1].score;
            document.getElementById('p2Errors').innerText = players[1].errors;
            const p1Card = document.getElementById('p1Card');
            const p2Card = document.getElementById('p2Card');
            if (currentPlayerIndex === 0) {
                p1Card.classList.add('active');
                p2Card.classList.remove('active');
            } else {
                p1Card.classList.remove('active');
                p2Card.classList.add('active');
            }
        }

        function updateTimerDisplay() {
            const delta = Math.floor((Date.now() - startTime) / 1000);
            const mins = Math.floor(delta / 60).toString().padStart(2, '0');
            const secs = (delta % 60).toString().padStart(2, '0');
            document.getElementById('timerDisplay').innerText = `${mins}:${secs}`;
        }

        function createGrid() {
            const isPortrait = window.innerHeight > window.innerWidth;
            const cols = isPortrait ? 3 : 4;
            const rows = Math.ceil(cards.length / cols);
            const isMobile = window.innerWidth < 600;
            
            // M√°rgenes equilibrados
            const marginX = isMobile ? window.innerWidth * 0.08 : window.innerWidth * 0.1; 
            const marginYStart = isMobile ? 100 : window.innerHeight * 0.15; 
            const marginYEnd = isMobile ? 50 : window.innerHeight * 0.1;
            const gap = isMobile ? 15 : 25; 
            
            const availableW = window.innerWidth - (marginX * 2) - (gap * (cols - 1));
            const availableH = window.innerHeight - marginYStart - marginYEnd - (gap * (rows - 1));
            const cardSize = Math.min(availableW / cols, availableH / rows);

            const totalGridW = (cardSize * cols) + (gap * (cols - 1));
            const startX = (window.innerWidth - totalGridW) / 2;

            cards.forEach((card, i) => {
                const col = i % cols;
                const row = Math.floor(i / cols);
                card.w = cardSize;
                card.h = cardSize;
                card.baseX = startX + col * (cardSize + gap);
                card.baseY = marginYStart + row * (cardSize + gap);
                card.x = card.baseX;
                card.y = card.baseY;
            });
        }

        // --- CORRECCI√ìN FINAL AQU√ç ---
        function handleCardInteraction(cursorX, cursorY) {
            if (lockBoard) return;
            
            // SELECCI√ìN INVERTIDA: (1 - cursorX)
            // Esto corrige el efecto espejo en la selecci√≥n de cartas,
            // mientras que el punto verde se dibuja con la coordenada normal.
            const pixelX = (1 - cursorX) * canvasElement.width; 
            const pixelY = cursorY * canvasElement.height;
            
            for (let card of cards) {
                if (!card.isFlipped && !card.isMatched) {
                    if (pixelX > card.x && pixelX < card.x + card.w &&
                        pixelY > card.y && pixelY < card.y + card.h) {
                        flipCard(card);
                        break; 
                    }
                }
            }
        }

        function flipCard(card) {
            playSound('flip');
            card.isFlipped = true;
            flippedCards.push(card);
            card.scale = 1.15; 
            if (flippedCards.length === 2) checkForMatch();
        }

        function checkForMatch() {
            lockBoard = true;
            const [card1, card2] = flippedCards;
            if (card1.emoji === card2.emoji) {
                playSound('match');
                players[currentPlayerIndex].score++;
                matchesFound++;
                card1.isMatched = true;
                card2.isMatched = true;
                createExplosion(card1.x + card1.w/2, card1.y + card1.h/2);
                createExplosion(card2.x + card2.w/2, card2.y + card2.h/2);
                speak("¬°" + card1.name + "!");
                updateHUD();
                resetBoard();
                if (matchesFound === totalPairs) endGame();
            } else {
                playSound('error');
                players[currentPlayerIndex].errors++;
                updateHUD();
                setTimeout(() => {
                    card1.isFlipped = false;
                    card2.isFlipped = false;
                    currentPlayerIndex = (currentPlayerIndex + 1) % 2;
                    updateHUD();
                    speak("Turno de " + players[currentPlayerIndex].name);
                    resetBoard();
                }, 1500);
            }
        }

        function resetBoard() {
            [lockBoard, flippedCards] = [false, []];
        }

        function endGame() {
            clearInterval(timerInterval);
            const totalTime = document.getElementById('timerDisplay').innerText;
            setTimeout(() => {
                document.getElementById('victoryScreen').classList.remove('hidden');
                document.getElementById('gameHUD').classList.add('hidden');
                document.getElementById('sumP1Name').innerText = players[0].name;
                document.getElementById('sumP1Score').innerText = players[0].score;
                document.getElementById('sumP1Errors').innerText = players[0].errors;
                document.getElementById('sumP2Name').innerText = players[1].name;
                document.getElementById('sumP2Score').innerText = players[1].score;
                document.getElementById('sumP2Errors').innerText = players[1].errors;
                document.getElementById('sumTime').innerText = totalTime;
                const winnerElem = document.getElementById('winnerText');
                if (players[0].score > players[1].score) {
                    winnerElem.innerText = `üèÜ ¬°Ganador: ${players[0].name}!`;
                    speak(`Felicidades ${players[0].name}, has ganado.`);
                } else if (players[1].score > players[0].score) {
                    winnerElem.innerText = `üèÜ ¬°Ganador: ${players[1].name}!`;
                    speak(`Felicidades ${players[1].name}, has ganado.`);
                } else {
                    winnerElem.innerText = "ü§ù ¬°Empate!";
                    speak("Es un empate.");
                }
            }, 1000);
        }

        function createExplosion(x, y) {
            for (let i = 0; i < 40; i++) {
                particles.push({
                    x: x, y: y,
                    vx: (Math.random() - 0.5) * 15,
                    vy: (Math.random() - 0.5) * 15,
                    life: 1.0,
                    color: `hsl(${Math.random()*360}, 100%, 70%)`
                });
            }
        }

        function drawParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life -= 0.03;
                if (p.life <= 0) particles.splice(i, 1);
                else {
                    ctx.globalAlpha = p.life;
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 6, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            ctx.globalAlpha = 1.0;
        }

        function onResults(results) {
            if (!gameActive) return;
            document.getElementById('loadingMsg').classList.add('hidden');
            ctx.save();
            ctx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            ctx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
            ctx.translate(canvasElement.width, 0);
            ctx.scale(-1, 1);
            const time = Date.now() * 0.002;

            cards.forEach(card => {
                const floatY = Math.sin(time + card.floatOffset) * 5; 
                card.y = card.baseY + floatY;
                if (card.scale > 1) card.scale -= 0.02;
                const cx = card.x + card.w/2;
                const cy = card.y + card.h/2;
                ctx.translate(cx, cy);
                ctx.scale(card.scale, card.scale);
                ctx.translate(-cx, -cy);
                ctx.beginPath();
                ctx.roundRect(card.x, card.y, card.w, card.h, 15);
                if (card.isFlipped || card.isMatched) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.85)';
                    ctx.fill();
                    ctx.strokeStyle = '#FFD700';
                    ctx.lineWidth = card.isMatched ? 6 : 3;
                    ctx.stroke();
                    ctx.font = `${card.w * 0.6}px Arial`;
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    ctx.fillStyle = "black";
                    ctx.fillText(card.emoji, card.x + card.w/2, card.y + card.h/2);
                } else {
                    ctx.fillStyle = 'rgba(20, 40, 70, 0.5)'; 
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    ctx.font = `${card.w * 0.4}px Arial`;
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    ctx.fillStyle = "rgba(255, 255, 255, 0.5)";
                    ctx.fillText("?", card.x + card.w/2, card.y + card.h/2);
                }
                ctx.setTransform(1, 0, 0, 1, 0, 0); 
                ctx.translate(canvasElement.width, 0);
                ctx.scale(-1, 1);
            });
            drawParticles();
            ctx.restore(); 

            if (results.multiHandLandmarks) {
                for (const landmarks of results.multiHandLandmarks) {
                    drawConnectors(ctx, landmarks, HAND_CONNECTIONS, {color: 'rgba(0, 255, 0, 0.4)', lineWidth: 2});
                    drawLandmarks(ctx, landmarks, {color: 'rgba(255, 0, 0, 0.4)', lineWidth: 1, radius: 3});
                    const indexTip = landmarks[8];
                    const thumbTip = landmarks[4];
                    const distance = Math.hypot(indexTip.x - thumbTip.x, indexTip.y - thumbTip.y);
                    const isPinching = distance < 0.08;
                    const cx = (indexTip.x + thumbTip.x) / 2;
                    const cy = (indexTip.y + thumbTip.y) / 2;
                    
                    // --- PUNTO VERDE NORMAL (SIN INVERTIR) ---
                    const cursorX = cx * canvasElement.width; 
                    const cursorY = cy * canvasElement.height;
                    
                    ctx.beginPath();
                    ctx.arc(cursorX, cursorY, 15, 0, Math.PI*2);
                    ctx.fillStyle = isPinching ? 'rgba(0, 255, 0, 0.7)' : 'rgba(255, 255, 255, 0.3)';
                    ctx.fill();
                    ctx.strokeStyle = isPinching ? '#00FF00' : '#FFFFFF';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    if (!isPinching) {
                        ctx.beginPath();
                        ctx.arc(cursorX, cursorY, 20, 0, Math.PI*2);
                        ctx.strokeStyle = 'rgba(255,255,255,0.1)';
                        ctx.stroke();
                    }

                    if (isPinching && !wasPinching && Date.now() > pinchCooldown) {
                        // Pasamos 'cx' normal. La inversi√≥n se hace DENTRO de handleCardInteraction
                        handleCardInteraction(cx, cy); 
                        pinchCooldown = Date.now() + 500; 
                    }
                    wasPinching = isPinching;
                }
            }
        }

        function resetGame() {
            document.getElementById('victoryScreen').classList.add('hidden');
            document.getElementById('menuScreen').classList.remove('hidden');
            gameActive = false;
        }
        function backToMenu() {
            resetGame();
            document.getElementById('gameHUD').classList.add('hidden');
            document.getElementById('backBtn').classList.remove('show');
            if(timerInterval) clearInterval(timerInterval);
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({
            maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5
        });
        hands.onResults(onResults);

        async function startCamera() {
            const camera = new Camera(videoElement, {
                onFrame: async () => { await hands.send({image: videoElement}); },
                width: 1280, height: 720
            });
            camera.start();
        }
    </script>
</body>
</html>
