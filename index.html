<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Memorama AR - Multijugador</title>
    <style>
        /* --- ESTILOS GENERALES --- */
        * { box-sizing: border-box; margin: 0; padding: 0; -webkit-tap-highlight-color: transparent; }
        body {
            background: #111;
            color: white;
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden;
            position: fixed;
            width: 100%; height: 100%;
        }
        .container { position: relative; width: 100vw; height: 100vh; }
        
        #input_video { display: none; }
        #output_canvas {
            position: absolute; left: 0; top: 0;
            width: 100%; height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }
        
        /* --- INTERFAZ DE CRISTAL (UI) --- */
        .menu, .victory, .loading {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 30; 
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(8px);
            text-align: center;
            padding: 20px;
        }
        .hidden { display: none !important; }
        
        h1 { font-size: 2.5rem; margin-bottom: 1rem; text-shadow: 0 4px 10px rgba(0,0,0,0.5); color: #FFD700; }
        
        /* LOGIN STYLES */
        .login-container {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            width: 100%;
            max-width: 400px;
            margin-bottom: 20px;
        }
        
        .input-group { margin-bottom: 15px; text-align: left; }
        .input-group label { display: block; margin-bottom: 5px; font-weight: bold; font-size: 0.9rem; }
        .login-input {
            width: 100%;
            padding: 12px;
            border-radius: 10px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            background: rgba(0, 0, 0, 0.3);
            color: white;
            font-size: 1.1rem;
            outline: none;
            text-align: center;
        }
        .login-input:focus { border-color: #FFD700; background: rgba(0, 0, 0, 0.5); }

        /* BOTONES */
        .grid-btn {
            background: linear-gradient(135deg, #e0e0e0, #ffffff);
            color: #333; border: none; padding: 15px 30px;
            margin: 10px; border-radius: 50px; font-size: 1.1rem; font-weight: bold;
            cursor: pointer; transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            min-width: 150px;
        }
        .grid-btn:hover { transform: scale(1.05); box-shadow: 0 6px 20px rgba(0,0,0,0.4); }
        .grid-btn:active { transform: scale(0.95); }

        /* HUD (Marcador en juego) */
        .hud {
            position: absolute; top: 0; left: 0; width: 100%;
            padding: 15px;
            display: flex; justify-content: space-between; align-items: flex-start;
            z-index: 20;
            pointer-events: none; /* Dejar pasar clicks al bot√≥n de salir */
        }
        
        .player-card {
            background: rgba(0, 0, 0, 0.6);
            padding: 10px 20px;
            border-radius: 15px;
            border: 2px solid transparent;
            transition: all 0.3s;
        }
        
        .player-card.active {
            border-color: #00FF00;
            background: rgba(0, 50, 0, 0.7);
            transform: scale(1.1);
            box-shadow: 0 0 15px #00FF00;
        }

        .timer-box {
            position: absolute; top: 15px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.6); padding: 5px 15px; border-radius: 20px;
            font-size: 1.5rem; font-weight: bold; font-family: monospace;
        }

        /* TABLA DE RESUMEN */
        .summary-table {
            width: 100%; max-width: 500px;
            border-collapse: collapse;
            margin: 20px 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            overflow: hidden;
        }
        .summary-table th, .summary-table td {
            padding: 12px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            text-align: center;
        }
        .summary-table th { background: rgba(0, 0, 0, 0.3); color: #FFD700; }
        .winner-text { color: #00FF00; font-weight: bold; font-size: 1.2rem; margin-top: 10px; }

        .back-btn {
            position: absolute; bottom: 20px; right: 20px; z-index: 25;
            background: rgba(255, 50, 50, 0.8); color: white;
            padding: 10px 20px; border-radius: 20px;
            border: none; font-weight: bold; cursor: pointer; display: none;
            pointer-events: auto;
        }
        .back-btn.show { display: block; }
    </style>
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div class="container">
        
        <div id="menuScreen" class="menu">
            <h1>üë• Memorama VS</h1>
            
            <div class="login-container">
                <div class="input-group">
                    <label>Jugador 1</label>
                    <input type="text" id="p1Input" class="login-input" placeholder="Nombre J1" value="Jugador 1">
                </div>
                <div class="input-group">
                    <label>Jugador 2</label>
                    <input type="text" id="p2Input" class="login-input" placeholder="Nombre J2" value="Jugador 2">
                </div>
            </div>

            <p style="margin-bottom: 15px; opacity: 0.8;">Elige Categor√≠a para Empezar:</p>
            <div>
                <button class="grid-btn" onclick="startGame('animals')">üê∂ Animales</button>
                <button class="grid-btn" onclick="startGame('fruits')">üçé Frutas</button>
                <button class="grid-btn" onclick="startGame('vehicles')">üöó Veh√≠culos</button>
            </div>
        </div>

        <div id="gameHUD" class="hud hidden">
            <div id="p1Card" class="player-card active">
                <div id="p1NameDisplay" style="font-weight:bold;">Jugador 1</div>
                <div>Pares: <span id="p1Score">0</span></div>
                <div style="font-size:0.8rem; color:#ffaaaa;">Errores: <span id="p1Errors">0</span></div>
            </div>

            <div class="timer-box" id="timerDisplay">00:00</div>

            <div id="p2Card" class="player-card">
                <div id="p2NameDisplay" style="font-weight:bold;">Jugador 2</div>
                <div>Pares: <span id="p2Score">0</span></div>
                <div style="font-size:0.8rem; color:#ffaaaa;">Errores: <span id="p2Errors">0</span></div>
            </div>
        </div>

        <div id="loadingMsg" class="loading hidden">
            <h2>üì∑ Iniciando c√°mara...</h2>
        </div>

        <div id="victoryScreen" class="victory hidden">
            <h1>üìä Resumen de Partida</h1>
            
            <table class="summary-table">
                <thead>
                    <tr>
                        <th>Jugador</th>
                        <th>Pares</th>
                        <th>Errores</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td id="sumP1Name">J1</td>
                        <td id="sumP1Score">0</td>
                        <td id="sumP1Errors" style="color:#ff6666">0</td>
                    </tr>
                    <tr>
                        <td id="sumP2Name">J2</td>
                        <td id="sumP2Score">0</td>
                        <td id="sumP2Errors" style="color:#ff6666">0</td>
                    </tr>
                </tbody>
            </table>

            <div style="margin-bottom: 20px;">
                <p>Tiempo Total: <span id="sumTime" style="font-weight:bold; font-size:1.2rem;">00:00</span></p>
                <p id="winnerText" class="winner-text">¬°Ganador: Nadie!</p>
            </div>

            <button class="grid-btn" onclick="resetGame()">üîÑ Nueva Partida</button>
            <button class="grid-btn" onclick="backToMenu()">üè† Men√∫ Principal</button>
        </div>

        <button id="backBtn" class="back-btn" onclick="backToMenu()">‚ùå Salir</button>
        
        <video id="input_video" playsinline></video>
        <canvas id="output_canvas"></canvas>
    </div>

    <script>
        const videoElement = document.getElementById('input_video');
        const canvasElement = document.getElementById('output_canvas');
        const ctx = canvasElement.getContext('2d');
        
        // --- DATA ---
        const categories = {
            animals: [
                { emoji: 'üê∂', name: 'Perro' }, { emoji: 'üê±', name: 'Gato' },
                { emoji: 'üê≠', name: 'Rat√≥n' }, { emoji: 'üê∞', name: 'Conejo' },
                { emoji: 'ü¶ä', name: 'Zorro' }, { emoji: 'üêª', name: 'Oso' }
            ],
            fruits: [
                { emoji: 'üçé', name: 'Manzana' }, { emoji: 'üçå', name: 'Pl√°tano' },
                { emoji: 'üçá', name: 'Uvas' }, { emoji: 'üçâ', name: 'Sand√≠a' },
                { emoji: 'üçì', name: 'Fresa' }, { emoji: 'üçí', name: 'Cereza' }
            ],
            vehicles: [
                { emoji: 'üöó', name: 'Coche' }, { emoji: 'üöì', name: 'Polic√≠a' },
                { emoji: 'üöÄ', name: 'Cohete' }, { emoji: 'üöÅ', name: 'Helic√≥ptero' },
                { emoji: 'üöÇ', name: 'Tren' }, { emoji: 'üö≤', name: 'Bicicleta' }
            ]
        };

        // --- ESTADO DEL JUEGO ---
        let cards = [];
        let flippedCards = [];
        let lockBoard = false;
        let matchesFound = 0;
        let totalPairs = 0;
        let particles = [];
        let gameActive = false;
        
        // Multiplayer State
        let players = [
            { name: "J1", score: 0, errors: 0 },
            { name: "J2", score: 0, errors: 0 }
        ];
        let currentPlayerIndex = 0; // 0 o 1
        
        // Timer State
        let startTime = 0;
        let timerInterval = null;

        // Input
        let wasPinching = false; 
        let pinchCooldown = 0;   
        
        // --- AUDIO ---
        function speak(text) {
            if ('speechSynthesis' in window) {
                window.speechSynthesis.cancel();
                const u = new SpeechSynthesisUtterance(text);
                u.lang = 'es-ES';
                u.rate = 1.1; 
                window.speechSynthesis.speak(u);
            }
        }

        // --- GESTI√ìN DE PANTALLA ---
        function resizeCanvas() {
            canvasElement.width = window.innerWidth;
            canvasElement.height = window.innerHeight;
            if(gameActive) createGrid(); 
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // --- L√ìGICA DE JUEGO ---
        function startGame(category) {
            // Obtener nombres de los inputs
            const name1 = document.getElementById('p1Input').value.trim() || "Jugador 1";
            const name2 = document.getElementById('p2Input').value.trim() || "Jugador 2";
            
            // Inicializar jugadores
            players = [
                { name: name1, score: 0, errors: 0 },
                { name: name2, score: 0, errors: 0 }
            ];
            currentPlayerIndex = 0; // Empieza jugador 1

            // UI Updates
            document.getElementById('menuScreen').classList.add('hidden');
            document.getElementById('victoryScreen').classList.add('hidden');
            document.getElementById('loadingMsg').classList.remove('hidden');
            document.getElementById('gameHUD').classList.remove('hidden');
            document.getElementById('backBtn').classList.add('show');

            updateHUD();

            if (!videoElement.srcObject) startCamera();
            else document.getElementById('loadingMsg').classList.add('hidden');

            // Preparar Cartas
            const items = categories[category];
            let deck = [...items, ...items]; 
            deck.sort(() => Math.random() - 0.5);

            totalPairs = items.length;
            matchesFound = 0;
            flippedCards = [];
            lockBoard = false;
            particles = [];

            cards = deck.map((item, index) => ({
                id: index,
                emoji: item.emoji,
                name: item.name,
                isFlipped: false,
                isMatched: false,
                x: 0, y: 0, w: 0, h: 0,
                scale: 1
            }));

            gameActive = true;
            createGrid();
            
            // Iniciar Timer
            startTime = Date.now();
            if(timerInterval) clearInterval(timerInterval);
            timerInterval = setInterval(updateTimerDisplay, 1000);

            speak("Turno de " + players[currentPlayerIndex].name);
        }

        function updateHUD() {
            // Actualizar nombres y scores
            document.getElementById('p1NameDisplay').innerText = players[0].name;
            document.getElementById('p1Score').innerText = players[0].score;
            document.getElementById('p1Errors').innerText = players[0].errors;

            document.getElementById('p2NameDisplay').innerText = players[1].name;
            document.getElementById('p2Score').innerText = players[1].score;
            document.getElementById('p2Errors').innerText = players[1].errors;

            // Resaltar jugador activo
            const p1Card = document.getElementById('p1Card');
            const p2Card = document.getElementById('p2Card');

            if (currentPlayerIndex === 0) {
                p1Card.classList.add('active');
                p2Card.classList.remove('active');
            } else {
                p1Card.classList.remove('active');
                p2Card.classList.add('active');
            }
        }

        function updateTimerDisplay() {
            const delta = Math.floor((Date.now() - startTime) / 1000);
            const mins = Math.floor(delta / 60).toString().padStart(2, '0');
            const secs = (delta % 60).toString().padStart(2, '0');
            document.getElementById('timerDisplay').innerText = `${mins}:${secs}`;
        }

        function createGrid() {
            // Dejar espacio arriba para el HUD
            const cols = window.innerWidth > window.innerHeight ? 4 : 3;
            const rows = Math.ceil(cards.length / cols);
            
            const gap = 20; 
            const marginX = window.innerWidth * 0.1; 
            const marginY = window.innerHeight * 0.25; // M√°s margen arriba para el HUD
            
            const availableW = window.innerWidth - (marginX * 2) - (gap * (cols - 1));
            const availableH = window.innerHeight - (marginY * 2) - (gap * (rows - 1));
            
            const cardSize = Math.min(availableW / cols, availableH / rows);

            cards.forEach((card, i) => {
                const col = i % cols;
                const row = Math.floor(i / cols);
                
                card.w = cardSize;
                card.h = cardSize;
                card.x = marginX + col * (cardSize + gap);
                card.y = marginY + row * (cardSize + gap);
            });
        }

        function handleCardInteraction(cursorX, cursorY) {
            if (lockBoard) return;
            
            // Invertir X por el espejo
            const pixelX = (1 - cursorX) * canvasElement.width; 
            const pixelY = cursorY * canvasElement.height;

            for (let card of cards) {
                if (!card.isFlipped && !card.isMatched) {
                    if (pixelX > card.x && pixelX < card.x + card.w &&
                        pixelY > card.y && pixelY < card.y + card.h) {
                        flipCard(card);
                        break; 
                    }
                }
            }
        }

        function flipCard(card) {
            card.isFlipped = true;
            flippedCards.push(card);
            card.scale = 1.15; 

            if (flippedCards.length === 2) {
                checkForMatch();
            }
        }

        function checkForMatch() {
            lockBoard = true;
            const [card1, card2] = flippedCards;

            if (card1.emoji === card2.emoji) {
                // --- ACIERTO (MATCH) ---
                players[currentPlayerIndex].score++; // Sumar punto
                matchesFound++;
                
                card1.isMatched = true;
                card2.isMatched = true;
                
                createExplosion(card1.x + card1.w/2, card1.y + card1.h/2);
                createExplosion(card2.x + card2.w/2, card2.y + card2.h/2);
                
                speak("¬°" + card1.name + "! Punto para " + players[currentPlayerIndex].name);
                
                updateHUD(); // Actualizar marcador
                resetBoard(); // El jugador MANTIENE el turno si acierta

                if (matchesFound === totalPairs) {
                    endGame();
                }
            } else {
                // --- ERROR (NO MATCH) ---
                players[currentPlayerIndex].errors++; // Sumar error
                updateHUD(); // Mostrar error inmediatamente

                // Cambio de turno
                setTimeout(() => {
                    card1.isFlipped = false;
                    card2.isFlipped = false;
                    
                    // Cambiar jugador
                    currentPlayerIndex = (currentPlayerIndex + 1) % 2;
                    updateHUD();
                    speak("Turno de " + players[currentPlayerIndex].name);
                    
                    resetBoard();
                }, 1500); // 1.5 segundos para ver el error
            }
        }

        function resetBoard() {
            [lockBoard, flippedCards] = [false, []];
        }

        function endGame() {
            clearInterval(timerInterval);
            const totalTime = document.getElementById('timerDisplay').innerText;
            
            setTimeout(() => {
                document.getElementById('victoryScreen').classList.remove('hidden');
                document.getElementById('gameHUD').classList.add('hidden');
                
                // Llenar tabla de resumen
                document.getElementById('sumP1Name').innerText = players[0].name;
                document.getElementById('sumP1Score').innerText = players[0].score;
                document.getElementById('sumP1Errors').innerText = players[0].errors;

                document.getElementById('sumP2Name').innerText = players[1].name;
                document.getElementById('sumP2Score').innerText = players[1].score;
                document.getElementById('sumP2Errors').innerText = players[1].errors;

                document.getElementById('sumTime').innerText = totalTime;

                // Determinar ganador
                const winnerElem = document.getElementById('winnerText');
                if (players[0].score > players[1].score) {
                    winnerElem.innerText = `üèÜ ¬°Ganador: ${players[0].name}!`;
                    speak(`Felicidades ${players[0].name}, has ganado.`);
                } else if (players[1].score > players[0].score) {
                    winnerElem.innerText = `üèÜ ¬°Ganador: ${players[1].name}!`;
                    speak(`Felicidades ${players[1].name}, has ganado.`);
                } else {
                    winnerElem.innerText = "ü§ù ¬°Es un Empate!";
                    speak("Es un empate. ¬°Bien jugado ambos!");
                }

            }, 1000);
        }

        // --- VISUALES ---
        function createExplosion(x, y) {
            for (let i = 0; i < 30; i++) {
                particles.push({
                    x: x, y: y,
                    vx: (Math.random() - 0.5) * 12,
                    vy: (Math.random() - 0.5) * 12,
                    life: 1.0,
                    color: `hsl(${Math.random()*360}, 100%, 70%)`
                });
            }
        }

        function drawParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life -= 0.04;
                if (p.life <= 0) particles.splice(i, 1);
                else {
                    ctx.globalAlpha = p.life;
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 6, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            ctx.globalAlpha = 1.0;
        }

        function onResults(results) {
            if (!gameActive) return;
            document.getElementById('loadingMsg').classList.add('hidden');

            ctx.save();
            ctx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            ctx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

            // Espejo para UI AR
            ctx.translate(canvasElement.width, 0);
            ctx.scale(-1, 1);

            cards.forEach(card => {
                if (card.scale > 1) card.scale -= 0.02;

                const cx = card.x + card.w/2;
                const cy = card.y + card.h/2;
                
                ctx.translate(cx, cy);
                ctx.scale(card.scale, card.scale);
                ctx.translate(-cx, -cy);

                // Estilo Cristal
                ctx.beginPath();
                ctx.roundRect(card.x, card.y, card.w, card.h, 15);
                
                if (card.isFlipped || card.isMatched) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.85)';
                    ctx.fill();
                    ctx.strokeStyle = '#FFD700';
                    ctx.lineWidth = card.isMatched ? 6 : 3;
                    ctx.stroke();
                    ctx.font = `${card.w * 0.6}px Arial`;
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    ctx.fillStyle = "black";
                    ctx.fillText(card.emoji, card.x + card.w/2, card.y + card.h/2);
                } else {
                    ctx.fillStyle = 'rgba(30, 50, 80, 0.5)'; 
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                    ctx.font = `${card.w * 0.4}px Arial`;
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    ctx.fillStyle = "rgba(255, 255, 255, 0.5)";
                    ctx.fillText("?", card.x + card.w/2, card.y + card.h/2);
                }
                
                ctx.setTransform(1, 0, 0, 1, 0, 0); 
                ctx.translate(canvasElement.width, 0);
                ctx.scale(-1, 1);
            });

            drawParticles();
            ctx.restore(); 

            // Hand Tracking
            if (results.multiHandLandmarks) {
                for (const landmarks of results.multiHandLandmarks) {
                    drawConnectors(ctx, landmarks, HAND_CONNECTIONS, {color: 'rgba(0, 255, 0, 0.6)', lineWidth: 2});
                    drawLandmarks(ctx, landmarks, {color: 'rgba(255, 0, 0, 0.6)', lineWidth: 1, radius: 3});

                    const indexTip = landmarks[8];
                    const thumbTip = landmarks[4];
                    const distance = Math.hypot(indexTip.x - thumbTip.x, indexTip.y - thumbTip.y);
                    const isPinching = distance < 0.08;
                    
                    const cx = (indexTip.x + thumbTip.x) / 2;
                    const cy = (indexTip.y + thumbTip.y) / 2;
                    const cursorX = (1 - cx) * canvasElement.width; 
                    const cursorY = cy * canvasElement.height;
                    
                    ctx.beginPath();
                    ctx.arc(cursorX, cursorY, 12, 0, Math.PI*2);
                    ctx.fillStyle = isPinching ? 'rgba(0, 255, 0, 0.8)' : 'rgba(255, 255, 255, 0.4)';
                    ctx.fill();
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    if (isPinching && !wasPinching && Date.now() > pinchCooldown) {
                        handleCardInteraction(cx, cy); 
                        pinchCooldown = Date.now() + 500; 
                    }
                    wasPinching = isPinching;
                }
            }
        }

        // --- INIT ---
        function resetGame() {
            document.getElementById('victoryScreen').classList.add('hidden');
            document.getElementById('menuScreen').classList.remove('hidden');
            gameActive = false;
        }
        function backToMenu() {
            resetGame();
            document.getElementById('gameHUD').classList.add('hidden');
            document.getElementById('backBtn').classList.remove('show');
            if(timerInterval) clearInterval(timerInterval);
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({
            maxNumHands: 1, 
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        hands.onResults(onResults);

        async function startCamera() {
            const camera = new Camera(videoElement, {
                onFrame: async () => { await hands.send({image: videoElement}); },
                width: 1280, height: 720
            });
            camera.start();
        }
    </script>
</body>
</html>
