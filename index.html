<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Memorama AR - Parlante</title>
    <style>
        /* ESTILOS GENERALES */
        * { box-sizing: border-box; margin: 0; padding: 0; -webkit-tap-highlight-color: transparent; }
        body {
            background: #111;
            color: white;
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden;
            position: fixed;
            width: 100%; height: 100%;
        }
        .container { position: relative; width: 100vw; height: 100vh; }
        
        #input_video { display: none; }
        #output_canvas {
            position: absolute; left: 0; top: 0;
            width: 100%; height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }
        
        /* INTERFAZ CRISTAL */
        .menu, .victory, .loading {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 30; 
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(5px);
            text-align: center;
        }
        .hidden { display: none !important; }
        
        h1 { font-size: 2.5rem; margin-bottom: 1rem; text-shadow: 0 4px 10px rgba(0,0,0,0.5); }
        
        .grid-btn {
            background: rgba(255, 255, 255, 0.9); 
            color: #333; border: none; padding: 15px 30px;
            margin: 10px; border-radius: 50px; font-size: 1.2rem; font-weight: bold;
            cursor: pointer; transition: transform 0.2s; box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }
        .grid-btn:hover { transform: scale(1.05); background: white; }
        
        .back-btn {
            position: absolute; top: 20px; right: 20px; z-index: 20;
            background: rgba(255,255,255,0.8); padding: 10px 20px; border-radius: 20px;
            border: none; font-weight: bold; cursor: pointer; display: none;
        }
        .back-btn.show { display: block; }

        .instructions {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            z-index: 15; 
            background: rgba(0, 0, 0, 0.5); 
            padding: 10px 25px;
            border-radius: 30px; 
            pointer-events: none; 
            font-size: 1.2rem;
            border: 1px solid rgba(255,255,255,0.3);
        }
    </style>
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div class="container">
        <div id="menuScreen" class="menu">
            <h1>üó£Ô∏è Memorama Parlante</h1>
            <p style="font-size: 1.2rem; margin-bottom: 20px; max-width: 80%;">Haz el gesto de "pinza" üëå para jugar.</p>
            <div>
                <button class="grid-btn" onclick="startGame('animals')">üê∂ Animales</button>
                <button class="grid-btn" onclick="startGame('fruits')">üçé Frutas</button>
                <button class="grid-btn" onclick="startGame('vehicles')">üöó Veh√≠culos</button>
            </div>
        </div>

        <div id="loadingMsg" class="loading hidden">
            <h2>üì∑ Iniciando c√°mara...</h2>
        </div>

        <div id="victoryScreen" class="victory hidden">
            <div style="font-size: 4rem;">üéâüèÜüéâ</div>
            <h1>¬°Lo lograste!</h1>
            <button class="grid-btn" onclick="resetGame()">üîÑ Jugar de nuevo</button>
            <button class="grid-btn" onclick="backToMenu()">üè† Men√∫</button>
        </div>

        <button id="backBtn" class="back-btn" onclick="backToMenu()">‚ùå Salir</button>
        
        <div id="instructions" class="instructions hidden">
            üëå Pellizca para voltear
        </div>

        <video id="input_video" playsinline></video>
        <canvas id="output_canvas"></canvas>
    </div>

    <script>
        const videoElement = document.getElementById('input_video');
        const canvasElement = document.getElementById('output_canvas');
        const ctx = canvasElement.getContext('2d');
        
        // --- 1. NUEVA ESTRUCTURA DE DATOS CON NOMBRES ---
        const categories = {
            animals: [
                { emoji: 'üê∂', name: 'Perro' },
                { emoji: 'üê±', name: 'Gato' },
                { emoji: 'üê≠', name: 'Rat√≥n' },
                { emoji: 'üê∞', name: 'Conejo' },
                { emoji: 'ü¶ä', name: 'Zorro' },
                { emoji: 'üêª', name: 'Oso' }
            ],
            fruits: [
                { emoji: 'üçé', name: 'Manzana' },
                { emoji: 'üçå', name: 'Pl√°tano' },
                { emoji: 'üçá', name: 'Uvas' },
                { emoji: 'üçâ', name: 'Sand√≠a' },
                { emoji: 'üçì', name: 'Fresa' },
                { emoji: 'üçí', name: 'Cereza' }
            ],
            vehicles: [
                { emoji: 'üöó', name: 'Coche' },
                { emoji: 'üöì', name: 'Polic√≠a' },
                { emoji: 'üöÄ', name: 'Cohete' },
                { emoji: 'üöÅ', name: 'Helic√≥ptero' },
                { emoji: 'üöÇ', name: 'Tren' },
                { emoji: 'üö≤', name: 'Bicicleta' }
            ]
        };

        let cards = [];
        let flippedCards = [];
        let lockBoard = false;
        let matchesFound = 0;
        let totalPairs = 0;
        let particles = [];
        let gameActive = false;
        let wasPinching = false; 
        let pinchCooldown = 0;   
        
        // --- AUDIO ---
        function speak(text) {
            if ('speechSynthesis' in window) {
                // Cancelar audio anterior para que no se amontonen
                window.speechSynthesis.cancel();
                
                const u = new SpeechSynthesisUtterance(text);
                u.lang = 'es-ES'; // Espa√±ol
                u.rate = 1.0;     // Velocidad normal
                u.pitch = 1.1;    // Tono ligeramente alegre
                
                window.speechSynthesis.speak(u);
            }
        }

        // --- CANVAS ---
        function resizeCanvas() {
            canvasElement.width = window.innerWidth;
            canvasElement.height = window.innerHeight;
            if(gameActive) createGrid(); 
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // --- L√ìGICA ---
        function startGame(category) {
            document.getElementById('menuScreen').classList.add('hidden');
            document.getElementById('loadingMsg').classList.remove('hidden');
            document.getElementById('backBtn').classList.add('show');
            document.getElementById('instructions').classList.remove('hidden');

            if (!videoElement.srcObject) startCamera();
            else document.getElementById('loadingMsg').classList.add('hidden');

            const items = categories[category];
            // Duplicar objetos para hacer pares
            let deck = [...items, ...items]; 
            deck.sort(() => Math.random() - 0.5);

            totalPairs = items.length;
            matchesFound = 0;
            flippedCards = [];
            lockBoard = false;
            particles = [];

            // Mapeamos el objeto ahora con 'name'
            cards = deck.map((item, index) => ({
                id: index,
                emoji: item.emoji,
                name: item.name, // Guardamos el nombre aqu√≠
                isFlipped: false,
                isMatched: false,
                x: 0, y: 0, w: 0, h: 0,
                scale: 1
            }));

            gameActive = true;
            createGrid();
            speak("Encuentra los pares");
        }

        function createGrid() {
            const cols = window.innerWidth > window.innerHeight ? 4 : 3;
            const rows = Math.ceil(cards.length / cols);
            
            const gap = 25; 
            const marginX = window.innerWidth * 0.15; 
            const marginY = window.innerHeight * 0.20; 
            
            const availableW = window.innerWidth - (marginX * 2) - (gap * (cols - 1));
            const availableH = window.innerHeight - (marginY * 2) - (gap * (rows - 1));
            
            const cardSize = Math.min(availableW / cols, availableH / rows);

            cards.forEach((card, i) => {
                const col = i % cols;
                const row = Math.floor(i / cols);
                
                card.w = cardSize;
                card.h = cardSize;
                card.x = marginX + col * (cardSize + gap);
                card.y = marginY + row * (cardSize + gap);
            });
        }

        function handleCardInteraction(cursorX, cursorY) {
            if (lockBoard) return;
            
            const pixelX = (1 - cursorX) * canvasElement.width; 
            const pixelY = cursorY * canvasElement.height;

            for (let card of cards) {
                if (!card.isFlipped && !card.isMatched) {
                    if (pixelX > card.x && pixelX < card.x + card.w &&
                        pixelY > card.y && pixelY < card.y + card.h) {
                        flipCard(card);
                        break; 
                    }
                }
            }
        }

        function flipCard(card) {
            card.isFlipped = true;
            flippedCards.push(card);
            card.scale = 1.15; 

            if (flippedCards.length === 2) {
                checkForMatch();
            }
        }

        function checkForMatch() {
            lockBoard = true;
            const [card1, card2] = flippedCards;

            if (card1.emoji === card2.emoji) {
                // --- MATCH ---
                matchesFound++;
                card1.isMatched = true;
                card2.isMatched = true;
                
                // Efectos visuales
                createExplosion(card1.x + card1.w/2, card1.y + card1.h/2);
                createExplosion(card2.x + card2.w/2, card2.y + card2.h/2);
                
                // --- 2. AQU√ç EST√Å EL CAMBIO DE AUDIO ---
                // Decimos el nombre de la figura encontrada
                speak("¬°" + card1.name + "!"); 

                resetBoard();
                
                if (matchesFound === totalPairs) {
                    setTimeout(() => {
                        document.getElementById('victoryScreen').classList.remove('hidden');
                        speak("¬°Excelente trabajo! Ganaste.");
                    }, 2000); // Damos tiempo a que termine de decir el nombre del √∫ltimo par
                }
            } else {
                // --- NO MATCH ---
                setTimeout(() => {
                    card1.isFlipped = false;
                    card2.isFlipped = false;
                    resetBoard();
                }, 1000);
            }
        }

        function resetBoard() {
            [lockBoard, flippedCards] = [false, []];
        }

        function createExplosion(x, y) {
            for (let i = 0; i < 30; i++) {
                particles.push({
                    x: x, y: y,
                    vx: (Math.random() - 0.5) * 12,
                    vy: (Math.random() - 0.5) * 12,
                    life: 1.0,
                    color: `hsl(${Math.random()*360}, 100%, 70%)`
                });
            }
        }

        function drawParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life -= 0.04;
                
                if (p.life <= 0) particles.splice(i, 1);
                else {
                    ctx.globalAlpha = p.life;
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 6, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            ctx.globalAlpha = 1.0;
        }

        function onResults(results) {
            if (!gameActive) return;
            document.getElementById('loadingMsg').classList.add('hidden');

            ctx.save();
            ctx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            
            // 1. VIDEO DE FONDO
            ctx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

            // 2. MODO ESPEJO PARA ELEMENTOS DE JUEGO
            ctx.translate(canvasElement.width, 0);
            ctx.scale(-1, 1);

            cards.forEach(card => {
                if (card.scale > 1) card.scale -= 0.02;

                const cx = card.x + card.w/2;
                const cy = card.y + card.h/2;
                
                ctx.translate(cx, cy);
                ctx.scale(card.scale, card.scale);
                ctx.translate(-cx, -cy);

                // --- ESTILO CRISTAL (Glassmorphism) ---
                ctx.beginPath();
                ctx.roundRect(card.x, card.y, card.w, card.h, 15);
                
                if (card.isFlipped || card.isMatched) {
                    // Frente (semitransparente blanco)
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.85)';
                    ctx.fill();
                    
                    ctx.strokeStyle = '#FFD700';
                    ctx.lineWidth = card.isMatched ? 6 : 3;
                    ctx.stroke();
                    
                    // Emoji
                    ctx.font = `${card.w * 0.6}px Arial`;
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    ctx.fillStyle = "black";
                    ctx.fillText(card.emoji, card.x + card.w/2, card.y + card.h/2);
                } else {
                    // Reverso (semitransparente oscuro para ver humano)
                    ctx.fillStyle = 'rgba(30, 50, 80, 0.5)'; 
                    ctx.fill();
                    
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                    
                    ctx.font = `${card.w * 0.4}px Arial`;
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    ctx.fillStyle = "rgba(255, 255, 255, 0.5)";
                    ctx.fillText("?", card.x + card.w/2, card.y + card.h/2);
                }
                
                ctx.setTransform(1, 0, 0, 1, 0, 0); 
                ctx.translate(canvasElement.width, 0);
                ctx.scale(-1, 1);
            });

            drawParticles();
            ctx.restore(); 

            // 3. MANOS
            if (results.multiHandLandmarks) {
                for (const landmarks of results.multiHandLandmarks) {
                    drawConnectors(ctx, landmarks, HAND_CONNECTIONS, {color: 'rgba(0, 255, 0, 0.6)', lineWidth: 2});
                    drawLandmarks(ctx, landmarks, {color: 'rgba(255, 0, 0, 0.6)', lineWidth: 1, radius: 3});

                    const indexTip = landmarks[8];
                    const thumbTip = landmarks[4];
                    const distance = Math.hypot(indexTip.x - thumbTip.x, indexTip.y - thumbTip.y);
                    const isPinching = distance < 0.08;
                    
                    const cx = (indexTip.x + thumbTip.x) / 2;
                    const cy = (indexTip.y + thumbTip.y) / 2;
                    const cursorX = (1 - cx) * canvasElement.width; 
                    const cursorY = cy * canvasElement.height;
                    
                    ctx.beginPath();
                    ctx.arc(cursorX, cursorY, 12, 0, Math.PI*2);
                    ctx.fillStyle = isPinching ? 'rgba(0, 255, 0, 0.8)' : 'rgba(255, 255, 255, 0.4)';
                    ctx.fill();
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    if (isPinching && !wasPinching && Date.now() > pinchCooldown) {
                        handleCardInteraction(cx, cy); 
                        pinchCooldown = Date.now() + 500; 
                    }
                    wasPinching = isPinching;
                }
            }
        }

        // --- SETUP ---
        function resetGame() {
            document.getElementById('victoryScreen').classList.add('hidden');
            startGame(Object.keys(categories)[0]); 
        }
        function backToMenu() {
            gameActive = false;
            document.getElementById('menuScreen').classList.remove('hidden');
            document.getElementById('victoryScreen').classList.add('hidden');
            document.getElementById('instructions').classList.add('hidden');
            document.getElementById('backBtn').classList.remove('show');
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({
            maxNumHands: 1, 
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        hands.onResults(onResults);

        async function startCamera() {
            const camera = new Camera(videoElement, {
                onFrame: async () => { await hands.send({image: videoElement}); },
                width: 1280, height: 720
            });
            camera.start();
        }
    </script>
</body>
</html>
